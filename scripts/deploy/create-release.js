'use strict'

// Creates a release asset in github for a tag with autogenerated changelogs following
// conventional-commit specifications.
//
// Usage: node create-release.js <token> <tag> [--deploy]
// token should be a github token capable of creating a release
// tag should be the tag for which the release should be created
// --deploy should be specified to actually create the release; if not specified, the script
//          will print what it would do but not do it
//
// The release will be created as a prerelease if this is a prerelease tag.
// It will always be created as a draft so that humans can review it before it goes live.
//
// The changelog content will be in the body of the release.

const assert = require('assert')
const parseArgs = require('./lib/parseArgs')
const conventionalGithubReleaser = require('conventional-github-releaser')
const conventionalChangelog = require('conventional-changelog')
const git = require('simple-git')
const semver = require('semver')

const ALLOWED_VERSION_TYPES = ['alpha', 'beta', 'candidate', 'production']
const USAGE = '\nUsage:\n node ./scripts/deploy/create-release <token> <tag> [--deploy]'

const COMMON_CONTEXTS = {
  host: 'https://github.com',
  owner: 'Opentrons',
  repository: 'opentrons',
  linkReferences: true
}

const CONTEXTS_FOR_PROJECT = {
  'protocol-designer': {
    title: 'Opentrons Protocol Designer',
    ...COMMON_CONTEXTS
  },
  'labware-library': {
    title: 'Opentrons Labware Library',
    ...COMMON_CONTEXTS
  },
  'docs': {
    title: 'Opentrons Python Protocol API Documentation',
    ...COMMON_CONTEXTS
  },
  'robot-stack': {
    title: 'Opentrons App and Robot Software',
    ...COMMON_CONTEXTS
  }
}

const detailsFromTag = (tag) => tag.includes('@') ? tag.split('@') : ['robot-stack', tag.substring(1)]
function tagFromDetails(project, version) {
  if (project === 'robot-stack') {
    return 'v' + version
  } else {
    return [project, version].join('@')
  }
}
function prefixForProject(project) {
  if (project === 'robot-stack') {
    return 'v*'
  } else {
    return project + '@*'
  }
}
const tagIsForProject = (tag, project) => detailsFromTag(tag)[0] === project
const releaseKind = version => (semver.prerelease(version)?.at(0) ?? 'production').split('-')[0]
const releasePriorityGEQ = (kindA, kindB) => ALLOWED_VERSION_TYPES.indexOf(kindA) >= ALLOWED_VERSION_TYPES.indexOf(kindB)

// Return the version to build a changelog from, which is the most recent version whose prerelease
// level is equal to or greater than the current tag. So
// - if currentVersion is a production version (no prerelease data), use the last production version
// - if currentVersion is a beta version, use the most recent version that is either beta or production
// - if currentVersion is an alpha version, use the most recent version of any kind
// currentVersion should be the version-part of the tag (i.e. not including project@, not including v)
// previousVersions should be an array of version-parts (see above) in descending semver order
function versionPrevious(currentVersion, previousVersions) {
  const currentReleaseKind = releaseKind(currentVersion)
  if (!ALLOWED_VERSION_TYPES.includes(currentReleaseKind)) {
    throw new Error(`Error: Prerelease tag ${currentReleaseKind} is not one of ${ALLOWED_VERSION_TYPES.join(', ')}`)
  }
  const from = previousVersions.indexOf(currentVersion)
  const notIncluding = previousVersions.slice(from+1)
  const releasesOfGEQKind = notIncluding.filter(
    version => releasePriorityGEQ(releaseKind(version), currentReleaseKind)
  )
  return releasesOfGEQKind.length === 0 ? null : releasesOfGEQKind[0]
}

async function main() {
  const { args, flags } = parseArgs(process.argv.slice(2))

  const [token, tag] = args
  if (!token || !tag) {
    throw new Error(USAGE)
  }

  const dryrun = !flags.includes('--deploy')

  const [project, currentVersion] = detailsFromTag(tag)

  console.log(`Tag ${tag} represents version ${currentVersion} of ${project}`)

  const allTags = (await git().tags([prefixForProject(project)])).all
  if (!allTags.includes(tag)) {
    throw new Error(`Tag ${tag} does not exist - create it before running this script`)
  }

  const sortedVersions = allTags.map(tag => detailsFromTag(tag)[1]).sort(semver.compare).reverse()

  const previousVersion = versionPrevious(currentVersion, sortedVersions)
  const previousTag = tagFromDetails(project, previousVersion)

  console.log(`Changelogs will be generated from tag ${previousTag} which is version ${previousVersion}`)

  const changelogStream = conventionalChangelog(
    {preset: 'angular'},
    {version: currentVersion, currentTag: tag, previousTag: tag, ...CONTEXTS_FOR_PROJECT[project]}
  )
  for await (const chunk of changelogStream) {
    console.count('chunk')
    console.log(chunk)
  }

}

// i will do anything to use await instead of promise chaining, except apparently set up babel
(async () => {
  try {
    await main()
  } catch (err) {
    console.error(err.message)
    process.exit(-1)
  }
})()
